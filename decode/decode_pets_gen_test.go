// Package Pets provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/weberr13/oapi-codegen DO NOT EDIT.
package decode_test

import (
	"fmt"
)

// Accommodation defines model for Accommodation.
type Accommodation struct {
	Class interface{} `json:"class,omitempty"`
	Title *string     `json:"title,omitempty"`
}

// Bark defines model for Bark.
type Bark struct {
	Type   *string `json:"type,omitempty"`
	Volume *int    `json:"volume,omitempty"`
}

// Cat defines model for Cat.
type Cat struct {
	FavSound interface{} `json:"favSound,omitempty"`
	Mood     *string     `json:"mood,omitempty"`
	Sound    interface{} `json:"sound,omitempty"`
	Type     *string     `json:"type,omitempty"`
}

// Dog defines model for Dog.
type Dog struct {
	Kind  *string     `json:"kind,omitempty"`
	Sound interface{} `json:"sound,omitempty"`
	Type  *string     `json:"type,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Growl defines model for Growl.
type Growl struct {
	Severity *string `json:"severity,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// House defines model for House.
type House struct {
	Name  *string `json:"name,omitempty"`
	Rooms *int    `json:"rooms,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// Kennel defines model for Kennel.
type Kennel struct {
	Name  *string `json:"name,omitempty"`
	Rooms *int    `json:"rooms,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// Meow defines model for Meow.
type Meow struct {
	Squeel *string `json:"squeel,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// Palace defines model for Palace.
type Palace struct {
	Halls  *int    `json:"Halls,omitempty"`
	Name   *string `json:"name,omitempty"`
	Towers *int    `json:"towers,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// PetOwner defines model for PetOwner.
type PetOwner struct {
	Age        *int             `json:"age,omitempty"`
	Dogs       *[]Dog           `json:"dogs,omitempty"`
	Favorite   interface{}      `json:"favorite,omitempty"`
	LivesIn    interface{}      `json:"livesIn,omitempty"`
	Name       *string          `json:"name,omitempty"`
	Owns       *[]Accommodation `json:"owns,omitempty"`
	PetLivesIn Accommodation   `json:"petLivesIn,omitempty"`
}

// Purr defines model for Purr.
type Purr struct {
	Heritage *Accommodation `json:"heritage,omitempty"`
	Type     *string        `json:"type,omitempty"`
}

// Shack defines model for Shack.
type Shack struct {
	Material *string `json:"material,omitempty"`
	Name     *string `json:"name,omitempty"`
	Type     *string `json:"type,omitempty"`
}

func factory(fm map[string]func() interface{}, path, dk string, o map[string]interface{}) (interface{}, error) {
	var dp interface{}
	var dv string
	var ok bool

	if dp, ok = o[dk]; !ok {
		return nil, fmt.Errorf("expecting OneOf object at path '%s' to to have a discriminator property '%s'", path, dk)
	}

	if dv, ok = dp.(string); !ok {
		return nil, fmt.Errorf("expecting OneOf field '%s's' discriminator property '%s' value to be a string", path, dk)
	}

	f, ok := fm[dv]
	if !ok {
		return nil, fmt.Errorf("Unknown discriminator value '%s' when handling OneOf field '%s'", path, dv)
	}
	return f(), nil
}

// Factory method for objects at path Accommodation.class
func Accommodation_class_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"Shack":  NewShack,
		"BARK":   NewKennel,
		"Palace": NewPalace,
		"House":  NewHouse,
	}
	return factory(fm, "Accommodation.class", "type", o)
}

// Factory method for objects at path Cat.favSound
func Cat_favSound_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"MEOW": NewMeow,
		"PURR": NewPurr,
	}
	return factory(fm, "Cat.favSound", "type", o)
}

// Factory method for objects at path Cat.sound
func Cat_sound_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"PURR": NewPurr,
		"LOUD": NewMeow,
		"WARN": NewGrowl,
	}
	return factory(fm, "Cat.sound", "type", o)
}

// Factory method for objects at path Dog.sound
func Dog_sound_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"BARK": NewBark,
	}
	return factory(fm, "Dog.sound", "type", o)
}

// Factory method for objects at path PetOwner.favorite
func PetOwner_favorite_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"Cat": NewCat,
		"Dog": NewDog,
	}
	return factory(fm, "PetOwner.favorite", "type", o)
}

// Factory method for objects at path PetOwner.livesIn
func PetOwner_livesIn_Factory(o map[string]interface{}) (interface{}, error) {
	fm := map[string]func() interface{}{
		"Palace": NewPalace,
		"House":  NewHouse,
	}
	return factory(fm, "PetOwner.livesIn", "type", o)
}

func SchemaPathFactory(path string) (func(map[string]interface{}) (interface{}, error), error) {
	// Map <StringPath, Factory>
	pathFactoryMap := map[string]func(map[string]interface{}) (interface{}, error){
		"Accommodation.class": Accommodation_class_Factory,
		"Cat.favSound":        Cat_favSound_Factory,
		"Cat.sound":           Cat_sound_Factory,
		"Dog.sound":           Dog_sound_Factory,
		"PetOwner.favorite":   PetOwner_favorite_Factory,
		"PetOwner.livesIn":    PetOwner_livesIn_Factory,
	}

	return pathFactoryMap[path], nil
}

func TypeFactory(kind string) (interface{}, error) {
	// Map <StringPath, Factory>
	var factoryMap = map[string]func() interface{}{
		"Accommodation.class(type=BARK)":   NewKennel,
		"Accommodation.class(type=House)":  NewHouse,
		"Accommodation.class(type=Palace)": NewPalace,
		"Accommodation.class(type=Shack)":  NewShack,
		"Cat.favSound(type=MEOW)":          NewMeow,
		"Cat.favSound(type=PURR)":          NewPurr,
		"Cat.sound(type=LOUD)":             NewMeow,
		"Cat.sound(type=PURR)":             NewPurr,
		"Cat.sound(type=WARN)":             NewGrowl,
		"Dog.sound(type=BARK)":             NewBark,
		"PetOwner.favorite(type=Cat)":      NewCat,
		"PetOwner.favorite(type=Dog)":      NewDog,
		"PetOwner.livesIn(type=House)":     NewHouse,
		"PetOwner.livesIn(type=Palace)":    NewPalace,
	}
	f, ok := factoryMap[kind]
	if !ok {
		return nil, fmt.Errorf("cannot find type %s", kind)
	}
	return f(), nil
}

func NewBark() interface{} {
	_d := "BARK"
	return &Bark{Type: &_d}
}

func (r Bark) Discriminator() string {
	return "type"
}

func NewCat() interface{} {
	_d := "Cat"
	return &Cat{Type: &_d}
}

func (r Cat) Discriminator() string {
	return "type"
}

func NewDog() interface{} {
	_d := "Dog"
	return &Dog{Type: &_d}
}

func (r Dog) Discriminator() string {
	return "type"
}

func NewGrowl() interface{} {
	_d := "WARN"
	return &Growl{Type: &_d}
}

func (r Growl) Discriminator() string {
	return "type"
}

func NewHouse() interface{} {
	_d := "House"
	return &House{Type: &_d}
}

func (r House) Discriminator() string {
	return "type"
}

func NewKennel() interface{} {
	_d := "BARK"
	return &Kennel{Type: &_d}
}

func (r Kennel) Discriminator() string {
	return "type"
}

func NewMeow() interface{} {
	_d := "MEOW"
	return &Meow{Type: &_d}
}

func (r Meow) Discriminator() string {
	return "type"
}

func NewPalace() interface{} {
	_d := "Palace"
	return &Palace{Type: &_d}
}

func (r Palace) Discriminator() string {
	return "type"
}

func NewPurr() interface{} {
	_d := "PURR"
	return &Purr{Type: &_d}
}

func (r Purr) Discriminator() string {
	return "type"
}

func NewShack() interface{} {
	_d := "Shack"
	return &Shack{Type: &_d}
}

func (r Shack) Discriminator() string {
	return "type"
}
